package pkg;

import biz.freshcode.learn.gwt.client.uispike.builder.BeanBuilder;
import com.google.gwt.user.client.ui.MenuItem;
import sun.reflect.generics.reflectiveObjects.TypeVariableImpl;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;

/**
 * Generates a bean builder so instead of:
 * <pre>
 * Margins m = new Margins();
 * m.setTop(0);
 * m.setRight(5);
 * m.setBottom(0);
 * m.setLeft(5);
 * return m;
 * </pre>
 * we can use
 * <pre>
 * return new MarginsBuilder()
 * .top(0)
 * .right(5)
 * .bottom(0)
 * .left(5)
 * .margins;
 *
 * </pre>
 *
 * Ideas:
 * - Regeneration capabilities
 * - Annotation indicating a custom method that should be retained
 * - Protected methods for customising behaviour
 * - Indent string (allows for tabs)
 */
public class BeanBuilderGenerator {
    static final Class CLASS = MenuItem.class;


    public static void main(String[] args) {
        System.out.println(generate(CLASS));
    }

    public static String generate(Class cls) {
        String simpleName = cls.getSimpleName();
        String varName = decapitalize(simpleName);
        String builderName = simpleName + "Builder";
        String src = "";

        src += line("import " + cls.getName().replaceAll("\\$", "."));
        src += line("import " + BeanBuilder.class.getName());

        src += "\n\n// Generated by " + BeanBuilderGenerator.class.getSimpleName();
        src += "\n@" + BeanBuilder.class.getSimpleName() + "(" + simpleName + ".class)";
        src += "\npublic class " + builderName + " {";
        src += line("  public final " + simpleName + " " + varName);

        // Constructors
        if (hasDefaultConstructor(cls)) {
            src += "\n\n  public " + builderName + "() {";
            src += line("    this(new " + simpleName + "())");
            src += "\n  }";
        }
        src += "\n\n  public " + builderName + "(" + simpleName + " v) {";
        src += line("    " + varName + " = v");
        src += "\n  }";

        // assignment methods
        for (Method m : cls.getMethods()) {
            boolean isSetter = isSetter(m);
            boolean hasGenerics = hasGenerics(m);
            if (isSetter || isAdder(m)) {

                // Support for multi-arg setters
                String signature = "";
                String args = "";
                int paramCount = m.getParameterTypes().length;
                for (int i = 0; i < paramCount; i ++) {
                    Class<?> typ = m.getParameterTypes()[i];
                    String argType = typ.getCanonicalName();
                    if (i == paramCount - 1 && m.isVarArgs()) argType = argType.replace("[]", "...");
                    String arg = "v" + i;
                    args = join(args, ", ", arg);
                    signature = join(signature, ", ", argType + " " + arg);
                }

                String methodName = isSetter ? shortName(m): m.getName();

                src += "\n";
                if (hasGenerics) src += ("\n/* Generics too hard at the moment");
                src += "\n  public " + builderName + " " + methodName + "(" + signature + ") {";
                src += line("    " + varName + "." + m.getName() + "(" + args + ")");
                src += line("    return this");
                src += "\n  }";
                if (hasGenerics) src +=("\n*/");
            }
        }

        // init method to pull all values from another instance
        /* Don't bother.  Not useful and not comprehensive
        src += "\n\n  public " + builderName + " initFrom(" + simpleName + " v) {";
        src += "\n    return this";
        Set<String> initCmds = new LinkedHashSet<String>(); // will remove dupes from overloaded setters
        for (Method m : cls.getMethods()) {
            if (isSetter(m) && hasGetter(cls, m)) {
                String cmd = "\n      ." + shortName(m) + "(v.g" + m.getName().substring(1) + "())";
                initCmds.add(cmd);
            }
        }
        for (String cmd : initCmds) src += cmd;
        src += ";";
        src += "\n  }";
        */

        src += "\n}";
        return src;
    }

    private static boolean hasGenerics(Method m) {
        for (Type t: m.getGenericParameterTypes()) {
            if (t instanceof TypeVariableImpl) return true;
        }
        return false;
    }

    /**
     * Joins the two strings together using the separator.  If either is empty then the separator is not used.
     */
    private static String join(String left, String sep, String right) {
        if (left.isEmpty()) return right;
        if (right.isEmpty()) return left;
        return left + sep + right;
    }

    /**
     * Returns 'true' if the given setter has a corrresponding getter method.
     */
    private static boolean hasGetter(Class cls, Method setter) {
        Class<?>[] types = setter.getParameterTypes();
        if (types.length > 1) return false; // no getter if setter has >1 arg
        String getterName = "g" + setter.getName().substring(1);
        try {
            Method getter = cls.getMethod(getterName);
            // Make sure types are compatible (EG. ContentPanel.getToolTip() is a problem child)
            boolean typesMatch = types[0].isAssignableFrom(getter.getReturnType());
            boolean isPrivate = Modifier.isPrivate(getter.getModifiers());
            return !isPrivate && typesMatch;
        } catch (NoSuchMethodException e) {
            return false;
        }
    }

    private static boolean hasDefaultConstructor(Class cls) {
        for (Constructor c : cls.getConstructors()) {
            if (c.getParameterTypes().length == 0) return true;
        }
        return false;
    }

    private static String decapitalize(String simpleName) {
        return Character.toLowerCase(simpleName.charAt(0)) + simpleName.substring(1);
    }

    private static boolean isSetter(Method m) {
        String name = m.getName();
        return name.length() > 3
                && name.startsWith("set")
                && Character.isUpperCase(name.charAt(3))
                && eligible(m);
    }

    private static boolean eligible(Method m) {
        int mods = m.getModifiers();
        return !Modifier.isPrivate(mods)
                && !Modifier.isStatic(mods)
                && isTrivialReturnType(m);
    }

    /**
     * Indicates the return type can be ignored.
     * Chaining methods are considered simple enough to include in builders.  EG: GWT's MenuBar.addItem()
     */
    private static boolean isTrivialReturnType(Method m) {
        Class<?> returnType = m.getReturnType();
        boolean isVoid = Void.TYPE.equals(returnType);
        Class<?>[] paramTypes = m.getParameterTypes();
        // TODO: Return type that is the same as the declared class is a chained method too.
        boolean isChained = (paramTypes.length == 1) && returnType.equals(paramTypes[0]);
        return isVoid || isChained;
    }

    private static boolean isAdder(Method m) {
        String name = m.getName();
        return name.startsWith("add")
                && (name.length() == 3 || Character.isUpperCase(name.charAt(3)))
                && eligible(m);
    }

    /**
     * Will return 'bruce' from method 'setBruce'.
     */
    private static String shortName(Method setter) {
        String setLess = setter.getName().substring(3);
        return decapitalize(setLess);
    }

    private static String line(String contents) {
        return "\n" + contents + ";";
    }
}
