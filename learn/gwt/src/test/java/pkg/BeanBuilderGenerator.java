package pkg;

import biz.freshcode.learn.gwt.client.uispike.builder.BeanBuilder;
import com.sencha.gxt.widget.core.client.container.SimpleContainer;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.List;
import java.util.ListIterator;

/**
 * Generates a bean builder so instead of:
 * <pre>
 * Margins m = new Margins();
 * m.setTop(0);
 * m.setRight(5);
 * m.setBottom(0);
 * m.setLeft(5);
 * return m;
 * </pre>
 * we can use
 * <pre>
 * return new MarginsBuilder()
 * .top(0)
 * .right(5)
 * .bottom(0)
 * .left(5)
 * .margins;
 *
 * </pre>
 */
public class BeanBuilderGenerator {
    static final Class CLASS = SimpleContainer.class;


    public static void main(String[] args) {
        System.out.println(generate(CLASS));
    }

    public static String generate(Class cls) {
        String simpleName = cls.getSimpleName();
        String varName = decapitalize(simpleName);
        String builderName = simpleName + "Builder";
        String src = "";

        src += line("import " + cls.getName().replaceAll("\\$", "."));
        src += line("import " + BeanBuilder.class.getName());

        src += "\n\n// Generated by " + BeanBuilderGenerator.class.getSimpleName();
        src += "\n@" + BeanBuilder.class.getSimpleName() + "(" + simpleName + ".class)";
        src += "\npublic class " + builderName + " {";
        src += line("  public final " + simpleName + " " + varName);

        // Constructors
        if (hasDefaultConstructor(cls)) {
            src += "\n\n  public " + builderName + "() {";
            src += line("    this(new " + simpleName + "())");
            src += "\n  }";
        }
        src += "\n\n  public " + builderName + "(" + simpleName + " v) {";
        src += line("    " + varName + " = v");
        src += "\n  }";

        // assignment methods
        for (Method m : cls.getMethods()) {
            boolean isSetter = isSetter(m);
            if (isSetter || isAdder(m)) {

                // Support for multi-arg setters
                List<Class<?>> types = Arrays.asList(m.getParameterTypes());
                String signature = "";
                String args = "";
                for (ListIterator<Class<?>> li = types.listIterator(); li.hasNext(); ) {
                    String canonicalName = li.next().getCanonicalName();
                    int ix = li.previousIndex();
                    String arg = "v" + ix;
                    args = join(args, ", ", arg);
                    signature = join(signature, ", ", canonicalName + " " + arg);
                }

                String methodName = isSetter ? shortName(m): m.getName();
                src += "\n\n  public " + builderName + " " + methodName + "(" + signature + ") {";
                src += line("    " + varName + "." + m.getName() + "(" + args + ")");
                src += line("    return this");
                src += "\n  }";
            }
        }

        // init method to pull all values from another instance
        /* Don't bother.  Not useful and not comprehensive
        src += "\n\n  public " + builderName + " initFrom(" + simpleName + " v) {";
        src += "\n    return this";
        Set<String> initCmds = new LinkedHashSet<String>(); // will remove dupes from overloaded setters
        for (Method m : cls.getMethods()) {
            if (isSetter(m) && hasGetter(cls, m)) {
                String cmd = "\n      ." + shortName(m) + "(v.g" + m.getName().substring(1) + "())";
                initCmds.add(cmd);
            }
        }
        for (String cmd : initCmds) src += cmd;
        src += ";";
        src += "\n  }";
        */

        src += "\n}";
        return src;
    }

    /**
     * Joins the two strings together using the separator.  If either is empty then the separator is not used.
     */
    private static String join(String left, String sep, String right) {
        if (left.isEmpty()) return right;
        if (right.isEmpty()) return left;
        return left + sep + right;
    }

    /**
     * Returns 'true' if the given setter has a corrresponding getter method.
     */
    private static boolean hasGetter(Class cls, Method setter) {
        Class<?>[] types = setter.getParameterTypes();
        if (types.length > 1) return false; // no getter if setter has >1 arg
        String getterName = "g" + setter.getName().substring(1);
        try {
            Method getter = cls.getMethod(getterName);
            // Make sure types are compatible (EG. ContentPanel.getToolTip() is a problem child)
            boolean typesMatch = types[0].isAssignableFrom(getter.getReturnType());
            boolean isPrivate = Modifier.isPrivate(getter.getModifiers());
            return !isPrivate && typesMatch;
        } catch (NoSuchMethodException e) {
            return false;
        }
    }

    private static boolean hasDefaultConstructor(Class cls) {
        for (Constructor c : cls.getConstructors()) {
            if (c.getParameterTypes().length == 0) return true;
        }
        return false;
    }

    private static String decapitalize(String simpleName) {
        return Character.toLowerCase(simpleName.charAt(0)) + simpleName.substring(1);
    }

    private static boolean isSetter(Method m) {
        String name = m.getName();
        return name.length() > 3
                && name.startsWith("set")
                && Character.isUpperCase(name.charAt(3))
                && eligible(m);
    }

    private static boolean eligible(Method m) {
        int mods = m.getModifiers();
        return !Modifier.isPrivate(mods)
                && !Modifier.isStatic(mods)
                && Void.TYPE.equals(m.getReturnType());
    }

    private static boolean isAdder(Method m) {
        String name = m.getName();
        return name.startsWith("add")
                && (name.length() == 3 || Character.isUpperCase(name.charAt(3)))
                && eligible(m);
    }

    /**
     * Will return 'bruce' from method 'setBruce'.
     */
    private static String shortName(Method setter) {
        String setLess = setter.getName().substring(3);
        return decapitalize(setLess);
    }

    private static String line(String contents) {
        return "\n" + contents + ";";
    }
}
