package pkg.di

import org.scalatest.Suite
import com.borachio.scalatest.MockFactory
import org.scala_tools.subcut.inject.{BindingModule, MutableBindingModule}
import Fixtures._
import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner

@RunWith(classOf[JUnitRunner])
class MockingTest extends Suite with MockFactory {

  import MockingTest._

  def testConfig() {
    val app = Config.inject[App](None)
    expect("hello world") {
      app.service.operation()
    }
  }

  def testMocking() {
    //Getting this error when trying to use a class.
    // java.lang.IllegalArgumentException: Unable to create proxy - possible classloader issue? Consider setting proxyClassLoaderStrategy
    // I think mocking a class requires a special build process to allow
    // classes generated by Borachio to get loaded ahead of the real class...
    // See http://www.paulbutcher.com/2011/07/power-mocking-in-scala-with-borachio/ (Building heading)
    val deepMock = mock[Deep]
    deepMock expects 'operation returns "bruce"

    object TestMod extends InitBinds {
      protected def initBinds(m: MutableBindingModule) {
        implicit val bm = this
        Config.bind(m)
        m.bind[Deep] toSingleInstance deepMock
      }
    }

    val app = TestMod.inject[App](None)
    expect("hello bruce") {
      app.service.operation()
    }
  }
}

object MockingTest {

  object Config extends InitBinds {
    def bind(m: MutableBindingModule)(implicit outer: BindingModule) {
      m.bind[Deep] toSingleInstance (new DeepImpl("world"))
      m.bind[Service] toSingleInstance (new Service())
      m.bind[App] toSingleInstance (new App())
    }

    protected def initBinds(m: MutableBindingModule) {bind(m)(this)}
  }

}
